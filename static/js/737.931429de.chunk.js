"use strict";(self.webpackChunk_3d_examples=self.webpackChunk_3d_examples||[]).push([[737],{9737:function(e,r,t){t.d(r,{qf:function(){return o}});var i=t(3562);function o(e){for(var r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),u=new Set(Object.keys(e[0].morphAttributes)),a={},n={},f=e[0].morphTargetsRelative,l=new i.u9r,m=0,h=0;h<e.length;++h){var g=e[h],b=0;if(t!==(null!==g.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(var d in g.attributes){if(!o.has(d))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+'. All geometries must have compatible attributes; make sure "'+d+'" attribute exists among all geometries, or in none of them.'),null;void 0===a[d]&&(a[d]=[]),a[d].push(g.attributes[d]),b++}if(b!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". Make sure all geometries have the same number of attributes."),null;if(f!==g.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(var c in g.morphAttributes){if(!u.has(c))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===n[c]&&(n[c]=[]),n[c].push(g.morphAttributes[c])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(g.userData),r){var v=void 0;if(t)v=g.index.count;else{if(void 0===g.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". The geometry must have either an index or a position attribute"),null;v=g.attributes.position.count}l.addGroup(m,v,h),m+=v}}if(t){for(var p=0,y=[],B=0;B<e.length;++B){for(var E=e[B].index,A=0;A<E.count;++A)y.push(E.getX(A)+p);p+=e[B].attributes.position.count}l.setIndex(y)}for(var G in a){var x=s(a[G]);if(!x)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+G+" attribute."),null;l.setAttribute(G,x)}for(var T in n){var w=n[T][0].length;if(0===w)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[T]=[];for(var R=0;R<w;++R){for(var U=[],H=0;H<n[T].length;++H)U.push(n[T][H][R]);var k=s(U);if(!k)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+T+" morphAttribute."),null;l.morphAttributes[T].push(k)}}return l}function s(e){for(var r,t,o,s=0,u=0;u<e.length;++u){var a=e[u];if(a.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===r&&(r=a.array.constructor),r!==a.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===t&&(t=a.itemSize),t!==a.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=a.normalized),o!==a.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;s+=a.array.length}for(var n=new r(s),f=0,l=0;l<e.length;++l)n.set(e[l].array,f),f+=e[l].array.length;return new i.TlE(n,t,o)}}}]);